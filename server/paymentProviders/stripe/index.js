import config from 'config';
import jwt from 'jsonwebtoken';
import qs from 'querystring';
import axios from 'axios';
import _ from 'lodash';
import debugLib from 'debug';

import models, { sequelize } from '../../models';
import activities from '../../constants/activities';
import errors from '../../lib/errors';
import { retrieveEvent, retrieveCharge, extractFees, retrieveBalanceTransaction } from './gateway';
import { planId } from '../../lib/utils';
import emailLib from '../../lib/email';
import currencies from '../../constants/currencies';
import creditcard from './creditcard';
// import bitcoin from './btc';

const debug = debugLib("stripe");


const AUTHORIZE_URI = 'https://connect.stripe.com/oauth/authorize';
const TOKEN_URI = 'https://connect.stripe.com/oauth/token';

const getToken = code => () => axios
  .post(TOKEN_URI, {
    grant_type: 'authorization_code',
    client_id: config.stripe.clientId,
    client_secret: config.stripe.secret,
    code
  })
  .then(res => res.data);


export default {

  // payment method types
  // like cc, btc, etc.
  types: {
    default: creditcard,
    creditcard
    //bitcoin
  },

  oauth: {

    // Returns the redirectUrl to connect the Stripe Account to the Host Collective Id
    redirectUrl: (remoteUser, CollectiveId) => {
      // Since we pass the redirectUrl in clear to the frontend, we cannot pass the CollectiveId in the state query variable
      // It would be trivial to change that value and attach a Stripe Account to someone else's collective
      // That's why we encode the state in a JWT
      const state = jwt.sign({
        CollectiveId,
        CreatedByUserId: remoteUser.id
      }, config.keys.opencollective.secret, {
        expiresIn: '45m' // People may need some time to set up their Stripe Account if they don't have one already
      });

      const params = qs.stringify({
        response_type: 'code',
        scope: 'read_write',
        client_id: config.stripe.clientId,
        redirect_uri: config.stripe.redirectUri,
        state
      });
      return Promise.resolve(`${AUTHORIZE_URI}?${params}`);
    },

    // callback called by Stripe after the user approves the connection
    callback: (req, res, next) => {
      let state, collective;
    
      try {
        state = jwt.verify(req.query.state, config.keys.opencollective.secret);
      } catch (e) {
        return next(new errors.BadRequest(`Invalid JWT: ${e.message}`));
      }
    
      const { CollectiveId, CreatedByUserId } = state;
    
      if (!CollectiveId) {
        return next(new errors.BadRequest('No state in the callback'));
      }
    
      const createStripeAccount = data => models.ConnectedAccount.create({
        service: 'stripe',
        CollectiveId,
        CreatedByUserId,
        username: data.stripe_user_id,
        token: data.access_token,
        refreshToken: data.refresh_token,
        data: {
          publishableKey: data.stripe_publishable_key,
          tokenType: data.token_type,
          scope: data.scope
        }
      });
    
      models.Collective.findById(CollectiveId)
        .then(c => {
          collective = c;
          if (collective.type === 'COLLECTIVE') {
            collective.becomeHost();
            collective.save();
            models.Member.create({
              CreatedByUserId,
              CollectiveId: collective.id,
              MemberCollectiveId: collective.id,
              role: 'HOST'
            })
          }
        })
        .then(getToken(req.query.code))
        .then(createStripeAccount)
        .then(() => res.redirect(`${config.host.website}/${collective.slug}?message=StripeAccountConnected`))
        .catch(next);
    }
  },

  processOrder: (order) => {
    return creditcard.processOrder(order);
  },

  webhook: (body) => {
    
    const isProduction = process.env.NODE_ENV === 'production';
    /**
     * We check the event on stripe to be sure we don't get a fake event from
     * someone else
     */
    return retrieveEvent({ username: body.user_id }, body.id)
      .then(event => {
        if (event.type !== 'invoice.payment_succeeded') {
          throw new errors.BadRequest('Wrong event type received');
        }

        const invoice = event.data.object;
        const invoiceLineItems = invoice.lines.data;
        const stripeSubscription = _.find(invoiceLineItems, { type: 'subscription' });
        const stripeSubscriptionId = stripeSubscription.id;

        /**
         * With connected accounts we get all the events of the account
         * We will return a 200 if the plan is not in our format (not generated by us)
         * Example: Ruby together has a subscription model outside of us.
         * https://dashboard.stripe.com/acct_15avvkAcWgwn5pBt/events/evt_17oYejAcWgwn5pBtRo5gRiyY
         */
        if (planId(stripeSubscription.plan) !== stripeSubscription.plan.id) {
          debug("fetchEvent", "unrecognized plan id", planId(stripeSubscription.plan), stripeSubscription.plan.id);
          return Promise.resolve();        
        }

        /*
         * In case we get $0 order, return 200. Otherwise, Stripe will keep pinging us.
         */
        if (event.data.object.amount_due === 0) {
          debug("fetchEvent", "event.data.object.amount_due is 0");
          return Promise.resolve();
        }

        // create activity to record webhook
        return models.Activity.create({
          type: activities.WEBHOOK_STRIPE_RECEIVED,
          data: {
            event,
            stripeAccount: body.user_id,
            eventId: body.id,
            dashboardUrl: `https://dashboard.stripe.com/${body.user_id}/events/${body.id}`
          }
        })

        // find the order
        .then(() => models.Order.findOne({
          include: [
            { model: models.User, as: 'createdByUser' },
            { model: models.Collective, as: 'fromCollective' },
            { model: models.Collective, as: 'collective' },
            { model: models.Subscription, where: { stripeSubscriptionId } },
            { model: models.PaymentMethod, as: 'paymentMethod' }
          ]
        }))
        .then(order => {
          /**
           * Stripe doesn't make a difference between development, test, staging
           * environments. If we get a webhook from another env,
           * `transaction.Subscription.stripeSubscriptionId`
           * will not be found and throw an error. Stripe will retry to send the webhook
           * if it doesn't get a 2XX status code.
           * For non-production environments, we will simply return 200 to avoid
           * the retry on Stripe side (and the email from Stripe support).
           */
          if (!order && !isProduction) {
            debug("fetchOrder", "order not found with subscription id", stripeSubscriptionId);
            return Promise.resolve();
          }

          if (!order) {
            throw new errors.BadRequest('Order not found: unknown subscription id');
          }

          // Confirm that this is a unique charge
          // deals with an bug where we found multiple transactions per chargeId
          const chargeId = event.data.object.charge;
          return sequelize.query(`
            SELECT * FROM "Transactions"
            WHERE 
              "OrderId" = ${order.id} AND
              CAST(data->'charge'->'id' AS TEXT) like '%${chargeId}%' AND
              "deletedAt" IS NULL
            `.replace(/\s\s+/g, ' '),
            {
              model: models.Transaction 
            })
            .then(t => {
              if (t.length > 0) {
                throw new errors.BadRequest(`This chargeId: ${chargeId} already exists.`);
              }
              // find customer and validate paymentMethod is associated with that customer
              // this check may not be needed
              const customer = event.data.object.customer;

              if (!customer) {
                throw new errors.BadRequest(`Customer Id not found. Order id: ${order.id}`);
              }
              if (!order.paymentMethod) {
                throw new errors.BadRequest('PaymentMethod not found');        
              }

              // For old subscriptions, they still reference the old customerId on the host stripe account
              if (order.paymentMethod.customerId !== customer) {
                // We need to iterate through the PaymentMethod.data.customerIdForHost[stripeAccount]
                const customerIdForHost = order.paymentMethod.data.customerIdForHost;
                if (customerIdForHost && !Object.values(customerIdForHost).find(c => c === customer)) {
                  throw new errors.BadRequest(`Customer Id not found. Order id: ${order.id}`);
                }
              }

              // Get the charge from Stripe
              return retrieveCharge({ username: body.user_id }, chargeId)
              .then(charge => {
                if (!charge) {
                  throw new errors.BadRequest(`ChargeId not found: ${chargeId}`);
                }
                // retreive balance, which has info we need to record transaction
                return retrieveBalanceTransaction({ username: body.user_id }, charge.balance_transaction)
                .then(balanceTransaction => {
                  if (!balanceTransaction) {
                    throw new errors.BadRequest(`Balance transaction not found for chargeId: ${charge.id}`);
                  }
                  // create transaction
                  const collective = order.collective || {};
                  const fees = extractFees(balanceTransaction);
                  const { hostFeePercent } = collective;

                  // Now we record a new transaction
                  const newTransaction = {
                    OrderId: order.id,
                    amount: stripeSubscription.amount,
                    currency: stripeSubscription.currency,
                    hostCurrency: balanceTransaction.currency,
                    amountInHostCurrency: balanceTransaction.amount,
                    hostCurrencyFxRate: order.totalAmount/balanceTransaction.amount,
                    hostFeeInHostCurrency: parseInt(balanceTransaction.amount*hostFeePercent/100, 10),
                    platformFeeInHostCurrency: fees.applicationFee,
                    paymentProcessorFeeInHostCurrency: fees.stripeFee,
                    data: {charge, balanceTransaction},
                    description: `${order.Subscription.interval}ly recurring subscription`,
                  };

                  return models.Transaction.createFromPayload({
                    CreatedByUserId: order.CreatedByUserId,
                    FromCollectiveId: order.FromCollectiveId,
                    CollectiveId: order.CollectiveId,
                    transaction: newTransaction,
                    PaymentMethodId: order.PaymentMethodId
                  })
                    // now we send receipt of transaction
                  .then(transaction => {
                    // We only send an invoice for orders > $10 equivalent
                    if (order.totalAmount < 10 * currencies[order.currency].fxrate * 100) {
                      return Promise.resolve();
                    }
                    const user = order.createdByUser || {};
                    const subscription = order.Subscription;
                    return collective.getRelatedCollectives(2, 0)
                      .then(relatedCollectives => emailLib.send(
                        'thankyou',
                        user.email,
                        { order: order.info,
                          transaction: transaction.info,
                          user: user.info,
                          firstPayment: false,
                          collective: collective.info,
                          fromCollective: order.fromCollective.minimal,
                          relatedCollectives,
                          config: { host: config.host },
                          interval: subscription && subscription.interval,
                          subscriptionsLink: user.generateLoginLink('/subscriptions')
                        }, {
                          from: `${collective.name} <hello@${collective.slug}.opencollective.com>`
                        }))
                  })
                })
              })
            })
        })
      })
   
  }

}